#include <iostream>
using namespace std;

/*???????娲???*/
typedef char VertexType;
typedef int EdgeType;

#define MAXVEX 100
#define INFINITY 65535
typedef int Pathmatrix[MAXVEX];     // ????娲????路???卤??????
typedef int ShortPathTable[MAXVEX]; // ????娲??????????路????????

typedef struct
{
    VertexType vexs[MAXVEX];
    EdgeType arc[MAXVEX][MAXVEX];
    int numVertexes, numEdges; // ?娲?????????????????
} MGraph;

/*???????????????????*/
void CreateMGraph(MGraph *G)
{
    int i, j, k, w;
    cout << "???????????????:" << endl;
    cin >> G->numVertexes >> G->numEdges;
    cout << "?????????" << endl;
    for (i = 0; i < G->numVertexes; i++)
    {
        cin >> G->vexs[i];
    }
    // ??????????
    for (i = 0; i < G->numVertexes; i++)
    {
        for (j = 0; j < G->numVertexes; j++)
        {
            G->arc[i][j] = INFINITY;
        }
    }
    for (k = 0; k < G->numEdges; k++)
    {
        cout << "?????卤?i,j???w" << endl;
        cin >> i >> j >> G->arc[i][j];
        G->arc[j][i] = G->arc[i][j];
    }
}

// P[V]????????????卤?D[V]???????v0??v?????路???????
void ShortestPath_Dijkstra(MGraph G, int v0, Pathmatrix *P, ShortPathTable *D)
{
    int v, w, k, min;
    int final[MAXVEX]; // final[w] = 1?????????v0??vw?????路??
    // ?????????
    for (v = 0; v < G.numVertexes; v++)
    {
        final[v] = 0;           // ????????????未????路????
        (*D)[v] = G.arc[v0][v]; // ????v0?????????????????
        (*P)[v] = 0;
    }
    (*D)[v0] = 0;  // v0??v0路???0
    final[v0] = 1; // v0??v0???????路??
    // ????????????????v0?????????????路??
    for (v = 1; v < G.numVertexes; v++)
    {
        min = INFINITY;
        for (w = 0; w < G.numVertexes; w++)
        {
            if (!final[w] && (*D)[w] < min)
            {
                k = w;
                min = (*D)[w]; // w??????v0???????
            }
        }
        final[k] = 1; // ????????????????????1
        /*??????????????????????v0??v1?????路????????????v1??????????????屑??????v0???????????????*/
        for (w = 0; w < G.numVertexes; w++)
        {
            // ???????v?????路????????????路?????????
            if (!final[w] && (min + G.arc[k][w] < (*D)[w]))
            {
                (*D)[w] = min + G.arc[k][w];
                (*P)[w] = k;
            }
        }
    }
}

int main()
{
    MGraph *G = new MGraph();
    CreateMGraph(G);
    Pathmatrix *P = new Pathmatrix[MAXVEX];
    ShortPathTable *D = new ShortPathTable[MAXVEX];
    ShortestPath_Dijkstra(*G, 0, P, D);
    delete P;
    delete D;
}